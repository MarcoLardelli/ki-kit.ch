<xml xmlns="https://developers.google.com/blockly/xml"><variables><variable id="?*6BRAKFM0arVn7PwrS7">delayAfterStop</variable><variable id="XzC[)AU*C,kOL{cXAFh7">pin</variable><variable id="w5C*N(At4ItB-=|Rk(r4">speed</variable><variable id="jwM#|qKoYX|UlDHBH_rh">leftMotor</variable><variable id="T!V6[*.1iM3@j7Vh$CQm">rightMotor</variable><variable id="1uYywvd0!KxevUfTh`AB">time</variable><variable id="7t@PC,5nwOP$Kc4/ZcpO">i</variable><variable id="v}^oFg[]a`p*.JoXs`@{">j</variable></variables><block type="basic_comment" id="c*1psuW5{{[(/Q/5J8Vo" x="117" y="-542"><field name="COMMENT">"Motti" by Marco Lardelli&amp;#10;Sketch zum Kurs-Kit künstliche Intelligenz und Robotik. Mehr Infos und Bauanleitung unter ki-ki.ch</field></block><block type="basic_comment" id="(2}-]m4(L4dIa}%JTm21" x="-612" y="-442"><field name="COMMENT">Daten aus den Lernspielen (serious games):&amp;#10;Füge hier den vom Computer generierten Code ein</field></block><block type="expert_setup" id="Lm0#Zq4ykUv^uSMlJ1iE" collapsed="true" x="119" y="-473"><statement name="CODE"><block type="code_input" id="HkpOj8X?E3E7@c1NCmFw"><field name="CODE_INPUT">pinMode(LED_BUILTIN, OUTPUT);</field></block></statement></block><block type="basic_comment" id="X#OWy6AX@K{z,][34%JB" x="-1077" y="-378"><field name="COMMENT">Funktionen (Unterprogramme) für Motoren und Sensoren&amp;#10;Hier muss nichts verändert werden</field></block><block type="code_declaration" id="h/8#+0Iq(BeN8N(UK7!;" collapsed="true" x="118" y="-426"><field name="CODE_DECLRATION">// ldr light sensor pins&amp;#10;int leftLightPin = 14;&amp;#10;int rightLightPin = 15;&amp;#10;int frontLightPin = 16;&amp;#10;int backLightPin = 17;&amp;#10;&amp;#10;// ambient light level, to be subtracted, measured at start&amp;#10;int leftLightStart = 0;&amp;#10;int rightLightStart = 0;&amp;#10;int frontLightStart = 0;&amp;#10;int backLightStart = 0;</field></block><block type="code_declaration" id="j:[%tg/1EE#Kb31%b$0x" x="-613" y="-380"><field name="CODE_DECLRATION">// ------------ computer generated code below this line, DO NOT MODIFY ------------&amp;#10;&amp;#10;// META PARAMETERS USED FOR TRAINING&amp;#10;// Generation: 143 of 200&amp;#10;// No of experiments per generation: 300&amp;#10;// Spot light displacement: 3.5&amp;#10;// Angular velocity punishment: 10000&amp;#10;// Runtime (episode duration in seconds): 4&amp;#10;// Initial weight max: 4&amp;#10;// Final weight max: 0.25&amp;#10;// Motor force multiplier: 10&amp;#10;// Number of Hidden nodes: 10&amp;#10;// Output activation function: NONE&amp;#10;// Include t minus one second: False&amp;#10;&amp;#10;// INFO&amp;#10;// Number of generations survived: 14&amp;#10;&amp;#10;const int InputNodes = 4;&amp;#10;const int HiddenNodes = 10;&amp;#10;const int OutputNodes = 2;&amp;#10;const float MotorForceMultiplier = 10;&amp;#10;const float InputScale = 10000;&amp;#10;&amp;#10;float HiddenWeights[InputNodes+1][HiddenNodes] = {&amp;#10;  {-10.5071 ,-28.6881 ,49.60723 ,-23.88357 ,-39.64715 ,-18.24572 ,-27.01153 ,-25.99557 ,15.14673 ,13.87427},&amp;#10;  {1.652861 ,-13.10295 ,6.646737 ,7.469599 ,33.07862 ,-2.438618 ,-10.64128 ,18.80143 ,31.26506 ,-14.81889},&amp;#10;  {21.20042 ,-13.02495 ,-11.88434 ,-12.08691 ,-23.28734 ,-34.93689 ,25.73363 ,-8.896099 ,-37.03425 ,-17.514},&amp;#10;  {-19.2657 ,-10.00093 ,-13.0666 ,23.542 ,-0.7619491 ,-26.32526 ,50.7839 ,16.5293 ,4.468988 ,-20.49962},&amp;#10;  {23.45566 ,19.99741 ,0.2138262 ,6.149847 ,6.500648 ,9.950813 ,-20.71023 ,31.42357 ,15.78693 ,27.31748}&amp;#10;};&amp;#10;&amp;#10;float OutputWeights[HiddenNodes+1][OutputNodes] = {&amp;#10;  {6.557656 ,1.594061},&amp;#10;  {7.629223 ,-0.2973841},&amp;#10;  {32.28601 ,27.33524},&amp;#10;  {0.560276 ,-0.8649625},&amp;#10;  {-48.71197 ,-2.280177},&amp;#10;  {24.57121 ,-10.00805},&amp;#10;  {-8.880691 ,-13.53585},&amp;#10;  {-30.56511 ,-25.8589},&amp;#10;  {-5.349677 ,-11.72226},&amp;#10;  {19.98512 ,-1.323637},&amp;#10;  {4.43928 ,25.86219}&amp;#10;};&amp;#10;&amp;#10;float Input[InputNodes] = {0,0,0,0};&amp;#10;float Hidden[HiddenNodes];&amp;#10;float Output[OutputNodes] = {0,0};&amp;#10;&amp;#10;// ------------- end of computer generated code ----------</field></block><block type="procedures_defnoreturn" id="A:Cd*j~,CKIGQvK@nd9C" collapsed="true" x="-1075" y="-310"><field name="NAME">CalibrateSensors</field><statement name="STACK"><block type="code_input" id="[XmI6K^zx}7g3lqVP7Z6"><field name="CODE_INPUT">  leftLightStart = 1023-analogRead(leftLightPin);&amp;#10;  rightLightStart = 1023-analogRead(rightLightPin);&amp;#10;  frontLightStart = 1023-analogRead(frontLightPin);&amp;#10;  backLightStart = 1023-analogRead(backLightPin);</field></block></statement></block><block type="procedures_defnoreturn" id="Nm8!mVWAf~agk)JlRtlk" collapsed="true" x="-1074" y="-270"><mutation><arg name="delayAfterStop" varid="?*6BRAKFM0arVn7PwrS7"></arg></mutation><field name="NAME">stop</field><statement name="STACK"><block type="code_input" id="^L1KAyOAur8d62r_B-?n"><field name="CODE_INPUT">  // beide Richtungen auf Low setzen&amp;#10;  pglu_motor(5,0);&amp;#10;  pglu_motor(6,0);&amp;#10;  delay(delayAfterStop);</field></block></statement></block><block type="basic_main_loop" id="tzh/Ks7}g`--7,m5uC5D" deletable="false" x="120" y="-328"><statement name="CODE"><block type="code_input" id="2,RWb}Wc*PjD+X,,74:2" collapsed="true"><field name="CODE_INPUT">// Kalibrierung&amp;#10;  stop(100);&amp;#10;  blinkSpeed(20);&amp;#10;  delay(5000);  // vor dem kalibrieren etwas warten&amp;#10;  blinkSpeed(200);&amp;#10;  &amp;#10;  CalibrateSensors();&amp;#10;&amp;#10;  int leftLight=0;&amp;#10;  int rightLight=0;&amp;#10;  int frontLight=0;&amp;#10;  int backLight=0;&amp;#10;&amp;#10;  float leftv =0;&amp;#10;  float rightv =0;&amp;#10;  float frontv =0;&amp;#10;  float backv =0;&amp;#10;&amp;#10;  float Accum;&amp;#10;  int i, j;</field><next><block type="flow_while" id="E#bwO{gV9AIAeXC^MEZO"><value name="CONDITION"><block type="basic_digital_state" id="f]r=d#~@)(pEz+_c5S={"><field name="STATE">HIGH</field></block></value><statement name="DO"><block type="led_write_percentage" id="rZT-{J$Nz5I@OkSv;.0m"><value name="LED"><block type="led_pin" id="qFN?;CKeKqaI,q|]*vZ?"><field name="LED">LED1</field></block></value><value name="VALUE"><block type="sensor_read_percentage" id="~)_h0J;6%Vu[#o;MQ6jA"><value name="SENSOR"><block type="sensor_pin" id="?!!du5#@j7m)UoA1ctVU"><field name="SENSOR">SENSOR1</field></block></value></block></value><next><block type="led_write_percentage" id="AG?Ldrj!l6Wz=J7C~kZE"><value name="LED"><block type="led_pin" id="[|Wi`ues-nLxwJ@k0;L_"><field name="LED">LED2</field></block></value><value name="VALUE"><block type="sensor_read_percentage" id="dW*YhUr5!}v3o}NV(_EN"><value name="SENSOR"><block type="sensor_pin" id=":{[%iR|NEUN9VX!)og}~"><field name="SENSOR">SENSOR2</field></block></value></block></value><next><block type="led_write_percentage" id="aqC7wK43$BQvK/0-(#x3"><value name="LED"><block type="led_pin" id="?e?xGpv2A`*{I`)_y3j0"><field name="LED">LED3</field></block></value><value name="VALUE"><block type="sensor_read_percentage" id=",XR#gfedGeZ(b!(a|o[+"><value name="SENSOR"><block type="sensor_pin" id="1Z8p`b]!XZ:JulJ:T.qP"><field name="SENSOR">SENSOR3</field></block></value></block></value><next><block type="led_write_percentage" id="4Ja0;Cc2C*Ibf-tB~0pF"><value name="LED"><block type="led_pin" id="VKJUW;!D#5-ZP_7Tc}N("><field name="LED">LED4</field></block></value><value name="VALUE"><block type="sensor_read_percentage" id="j,bQDVB|J/.9WcSLJ9#)"><value name="SENSOR"><block type="sensor_pin" id="7wSZ-2@yUNcz$sOM6FIO"><field name="SENSOR">SENSOR4</field></block></value></block></value><next><block type="code_input" id="Svwzx.wjYadohE8D~3*U" collapsed="true"><field name="CODE_INPUT">    // Von Lichtsensoren lesen, Umgebungslicht subtrahieren&amp;#10;    leftLight = 1023 - analogRead(leftLightPin)-leftLightStart;&amp;#10;    rightLight = 1023 - analogRead(rightLightPin)-rightLightStart;&amp;#10;    frontLight = 1023 - analogRead(frontLightPin)-frontLightStart;&amp;#10;    backLight = 1023 - analogRead(backLightPin)-backLightStart;&amp;#10;    // Auf ca. 0..1 skalieren&amp;#10;    leftv = leftLight / 512.0;&amp;#10;    rightv = rightLight / 512.0;&amp;#10;    frontv = frontLight / 512.0;&amp;#10;    backv = backLight / 512.0;</field><next><block type="code_input" id="Ji=qW}L|0KV.)1k|Bjd^"><field name="CODE_INPUT">Input[0] = frontv*InputScale;&amp;#10;Input[1] = leftv*InputScale;&amp;#10;Input[2] = rightv*InputScale;&amp;#10;Input[3] = backv*InputScale;</field><next><block type="flow_for" id="/S@nAr;%jyzlva?c]QX+"><field name="VAR" id="7t@PC,5nwOP$Kc4/ZcpO">i</field><value name="FROM"><block type="math_number" id="*C|+B=fPvw9BG7z`H3:4"><field name="NUM">0</field></block></value><value name="TO"><block type="code_pin" id="_.F(-7yCDMI?vxn3X$Li"><field name="CODE_PIN">HiddenNodes</field></block></value><value name="BY"><block type="math_number" id="~j0W.:=jQC*^j/UMr)Le"><field name="NUM">1</field></block></value><statement name="DO"><block type="code_input" id="?KBBHT^~XR;oW!yY#CQY"><field name="CODE_INPUT">Accum = HiddenWeights[InputNodes][i] ;</field><next><block type="flow_for" id="do3~rxNMGtsC_tIYEfvG"><field name="VAR" id="v}^oFg[]a`p*.JoXs`@{">j</field><value name="FROM"><block type="math_number" id="3~Hu[I7XWT:o#qJk#./|"><field name="NUM">0</field></block></value><value name="TO"><block type="code_pin" id="_%uMg6!#a_$wYkcN@8Dn"><field name="CODE_PIN">InputNodes</field></block></value><value name="BY"><block type="math_number" id="*`*qh[aBgyCXqKa26%l,"><field name="NUM">1</field></block></value><statement name="DO"><block type="code_input" id="eaElq,lm*be#$R`Yq^M$"><field name="CODE_INPUT">Accum += Input[j] * HiddenWeights[j][i] ;</field></block></statement><next><block type="logic_if" id="uUCg|G`I%g|:X(XRLH/["><mutation xmlns="http://www.w3.org/1999/xhtml" else="1"></mutation><value name="IF0"><block type="logic_compare" id="ddeW_}:h@z7V|6VftQst"><field name="OP">LT</field><value name="A"><block type="code_pin" id="+_P@QEy_=-*ekZI]g$])"><field name="CODE_PIN">Accum</field></block></value><value name="B"><block type="math_number" id="!DifbNd|t,VJOKDImnxF"><field name="NUM">0</field></block></value></block></value><statement name="DO0"><block type="code_input" id="g}zj[~Rn.X#`.h8{69@?"><field name="CODE_INPUT">Hidden[i] = 0.1*Accum;</field></block></statement><statement name="ELSE"><block type="code_input" id="$*_{=]=;@/f!N}1H8xA["><field name="CODE_INPUT">Hidden[i] = Accum;</field></block></statement></block></next></block></next></block></statement><next><block type="flow_for" id="+Lu[sZ%=0rEcC7N1s~KX"><field name="VAR" id="7t@PC,5nwOP$Kc4/ZcpO">i</field><value name="FROM"><block type="math_number" id="@LO=9J2Y}5@FaGb}Rrr+"><field name="NUM">0</field></block></value><value name="TO"><block type="code_pin" id="~[anPreFed)H[?AwmaZ@"><field name="CODE_PIN">OutputNodes</field></block></value><value name="BY"><block type="math_number" id="4kcLIQ3jMp/TzXY)4]-X"><field name="NUM">1</field></block></value><statement name="DO"><block type="code_input" id="/`%T^%b.^fKaL4h=W+vz"><field name="CODE_INPUT">Accum = OutputWeights[HiddenNodes][i] ;</field><next><block type="flow_for" id="[mwTV(m7MdkWbh_d;FBp"><field name="VAR" id="v}^oFg[]a`p*.JoXs`@{">j</field><value name="FROM"><block type="math_number" id="P*ihKagv0$PK)Qr;oa^|"><field name="NUM">0</field></block></value><value name="TO"><block type="code_pin" id="YWYHs-Pn;;p;F.:ln74V"><field name="CODE_PIN">HiddenNodes</field></block></value><value name="BY"><block type="math_number" id="$asXV5vAiB^qSr418PRB"><field name="NUM">1</field></block></value><statement name="DO"><block type="code_input" id="VdUg;|;/;/u#Eqd:sVf9"><field name="CODE_INPUT">Accum += Hidden[j] * OutputWeights[j][i] ;</field></block></statement><next><block type="code_input" id="Vz-E*dn(/g9F!pJ?CGo6"><field name="CODE_INPUT">Output[i] = Accum ; </field></block></next></block></next></block></statement><next><block type="procedures_callnoreturn" id="vY]Gr74LvV;v{v.42S(i"><mutation name="drive"><arg name="leftMotor"></arg><arg name="rightMotor"></arg><arg name="time"></arg></mutation><value name="ARG0"><block type="code_pin" id="@_2[~0}iJyB0|m`HRh5g"><field name="CODE_PIN">Output[0]*MotorForceMultiplier/10000</field></block></value><value name="ARG1"><block type="code_pin" id="7quv1m5OCHIf7A5oU}cI"><field name="CODE_PIN">Output[1]*MotorForceMultiplier/10000</field></block></value><value name="ARG2"><block type="math_number" id="c`tp}p@EfbE]0|JtkHHH"><field name="NUM">50</field></block></value></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></statement></block></next></block></statement></block><block type="procedures_defnoreturn" id="#8#9IfOMJZfjqPy9CbG3" collapsed="true" x="-1075" y="-225"><mutation><arg name="pin" varid="XzC[)AU*C,kOL{cXAFh7"></arg><arg name="speed" varid="w5C*N(At4ItB-=|Rk(r4"></arg></mutation><field name="NAME">pglu_motor</field><statement name="STACK"><block type="code_input" id="1t?Q#a_Y4p-^GU-(%zn4"><field name="CODE_INPUT">float sign;&amp;#10;  if (speed&gt;0){&amp;#10;    sign = 1;&amp;#10;  } else {&amp;#10;    sign = -1;&amp;#10;  }&amp;#10;  float pglu_speed = ((min(abs(speed),155)*sign/2.55 + 100)/2)*2.55;&amp;#10;  analogWrite(pin, pglu_speed);</field></block></statement></block><block type="procedures_defnoreturn" id="/Ct:3F}.dVJu56E*2Rj;" collapsed="true" x="-1076" y="-182"><field name="NAME">blink</field><statement name="STACK"><block type="code_input" id="OgoFKQ1TdQk$[QXL$e:S"><field name="CODE_INPUT">for(int i=0; i&lt;=5; i++){&amp;#10;    digitalWrite(LED_BUILTIN, HIGH);   // LED einschalten&amp;#10;    delay(100);                       // ein wenig warten&amp;#10;    digitalWrite(LED_BUILTIN, LOW);    // LED ausschalten&amp;#10;    delay(100); &amp;#10;  }</field></block></statement></block><block type="procedures_defnoreturn" id="uF{P)b*:30|*)?vim)!{" collapsed="true" x="-1076" y="-139"><mutation><arg name="speed" varid="w5C*N(At4ItB-=|Rk(r4"></arg></mutation><field name="NAME">blinkSpeed</field><statement name="STACK"><block type="code_input" id="%R~G.q.D#aJ74IXj3iPs"><field name="CODE_INPUT">  for(int i=0; i&lt;=5; i++){&amp;#10;    digitalWrite(LED_BUILTIN, HIGH);   // LED einschalten&amp;#10;    delay(255-speed);                       // ein wenig warten (abhängig von speed)&amp;#10;    digitalWrite(LED_BUILTIN, LOW);    // LED auschalten&amp;#10;    delay(255-speed); &amp;#10;  }</field></block></statement></block><block type="basic_comment" id="@3NB~qdn*XEc)t;5Yod;" x="924" y="-205"><field name="COMMENT">Anschlussbelegung am PGLU Controller</field></block><block type="procedures_defnoreturn" id="6RZQ:wo,A@!Kbi$@f}YA" collapsed="true" x="-1076" y="-97"><mutation><arg name="leftMotor" varid="jwM#|qKoYX|UlDHBH_rh"></arg><arg name="rightMotor" varid="T!V6[*.1iM3@j7Vh$CQm"></arg><arg name="time" varid="1uYywvd0!KxevUfTh`AB"></arg></mutation><field name="NAME">drive</field><statement name="STACK"><block type="code_input" id="u9yZgll#33z?Gx(o:vf~"><field name="CODE_INPUT">  pglu_motor(6, leftMotor);&amp;#10;  pglu_motor(5, rightMotor);&amp;#10;  delay(time);</field></block></statement></block><block type="basic_comment" id="3rq/m73w1NbF$wdWpj`~" x="989" y="-141"><field name="COMMENT">S3 &gt; Sensor vorne</field></block><block type="basic_comment" id="$CUhwWoac([Cq9:r9DXr" x="916" y="-104"><field name="COMMENT">S1 &gt; Sensor links</field></block><block type="basic_comment" id="hq8sDRQiD!iQnk4zR+u*" x="1058" y="-104"><field name="COMMENT">S2 &gt; Sensor rechts</field></block><block type="basic_comment" id="2sEB@:LTI-uhTM(au2Z~" x="990" y="-66"><field name="COMMENT">S4 &gt; Sensor hinten</field></block><block type="basic_comment" id="/bgr/,_Kp}+3x}O53={y" x="445" y="2"><field name="COMMENT">// In das input layer des neuronalen Netzes einspeisen</field></block><block type="basic_comment" id="5}`k?j8(BM?j-dg~}FQp" x="916" y="7"><field name="COMMENT">M1 &gt; Motor links</field></block><block type="basic_comment" id="!)j8B3TMxUgU]Qb|(C[W" x="1062" y="8"><field name="COMMENT">M2 &gt; Motor rechts</field></block><block type="basic_comment" id="W$NmYbG3h@3|(?TFkTb|" x="582" y="90"><field name="COMMENT">// Output des hidden Layer berechnen</field></block><block type="basic_comment" id="8iZzsgDt?,;=WGHm::(o" x="572" y="248"><field name="COMMENT"> // Aktivierungsfunktion (leaky ReLU)</field></block><block type="basic_comment" id="Ffb9=Y-wxVx1M(:,Z%#f" x="600" y="391"><field name="COMMENT">// Output des output Layers berechnen</field></block><block type="basic_comment" id="ogTuEs2K-)~?Q3eXNMO)" x="360" y="549"><field name="COMMENT">// keine Aktivierungsfunktion</field></block><block type="basic_comment" id="S{[5kHgd-S;(eZU+ObVp" x="959" y="596"><field name="COMMENT">// Output der output Neuronen ist Motorleistung</field></block></xml>